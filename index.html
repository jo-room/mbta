<!doctype html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>MBTA timings</title>
    </head>
    <style type="text/css">
        body {
            font-family: Arial;
            padding: 10px;
        }
        h1 {
            font-size: 1.5em;
            margin-block: 0;
        }
        h2 {
            font-size: 1em;
            margin-block-end: 0;
        }
        label {
            display: block;
            margin-top: 5px;
        }
        textarea {
          width:100%;
          margin: 5px 0;
          padding: 5px;
          -webkit-box-sizing: border-box;
          -moz-box-sizing: border-box;
          box-sizing: border-box;
        }
        input[type="text"] {
          width:100%;
          margin: 5px 0;
          padding: 5px;
          -webkit-box-sizing: border-box;
          -moz-box-sizing: border-box;
          box-sizing: border-box;
        }
        input[type="submit"] {
          margin: 5px 0;
          padding: 5px;
        }
        pre {
          white-space: pre-wrap;
          font-size: 0.8em;
        }
        .formInput {
            /*padding-top: 10px;
            margin: 0 10px;*/
        }
        .errorMessage {
            color: red;
            font-size: 0.8em;
            margin-bottom: 5px;
        }
        #content {
            font-size: 1.2em;
        }
        #urlOutput {
            padding: 10px 0;
        }
        /*#clock {
            font-size: 1em;
        }*/
        /*#configInput {
            margin: 10px 0;
        }*/
    </style>
    <body>
        <h1 id="title"></h1>
        <div id="subtitle">
            <span id="clock"></span>
            <span>Polls every minute</span>
        </div>
        <div id="message"></div>
        <div id="content"></div>
        <script type="text/javascript">
            var stopNums
            var stopConfigs = {}
            
            var msPerMin = 60 * 1000; // milliseconds per min
            var msPer55Min = 55 * msPerMin; // milliseconds per 55 min
            var msPerHour = 60 * msPerMin; // milliseconds per hour
            
            var pollingInterval = msPerMin;
            var pollNum = 0
            var latestReturnedPollNum = 0
            
            var pollIntervalID;
            
            var predictionData;

            var apiKey = getQueryVariable("key")
            var stopsQueryParam = getQueryVariable("stops")

            if (stopsQueryParam) {
                configureStops()
            } else {
                document.getElementById("title").innerText = "Generate URL"
                document.getElementById("subtitle").innerText = ""
                var el = document.createElement('div');
                el.innerHTML = `<form id="urlForm">
                  <div class="formInput">
                    <label for="stopIds">Stop ID(s), separated by commas:</label>
                    <input type="text" id="stopIdsInput" name="stopIds" />
                  </div>
                  <div class="errorMessage" id="stopIdsErrorMessage"></div>
                  <div class="formInput">
                    <label for="config">Optional configuration (must be valid JSON):</label>
                    <textarea id="configInput" name="config" cols="40" rows="3" ></textarea>
                  </div>
                  <div class="errorMessage" id="configInputErrorMessage"></div>
                  <div class="formInput">
                    <input type="submit" value="Generate URL" />
                  </div>
                </form>
                <div id="urlOutput"></div>
                <div>
                Example configuration for stop IDs 178,70154. All fields are optional.
                <pre>
{
    "title": "Example Title",
    "178": {
        "name": "Near Copley Square",
        "message": "5min away",
        "filterRoutes": ["39", "9"],
        "maxNumPredictions": 10
    },
    "70154": {
        "maxNumPredictions": 5
    }
}</pre>
                </div>
                <div>Most bus stop IDs can be found on Google Maps. If not, I tried making a search <a href="https://jo-room.github.io/mbta/stops/">here</a></div>
                `
                document.getElementById("content").appendChild(el)
                document.getElementById("urlForm").addEventListener("submit", encodeAndUpdate);
            }

            function isJsonString(str) {
                try {
                    JSON.parse(str);
                } catch (e) {
                    return false;
                }
                return true;
            }

            function encodeAndUpdate(e) {
                e.preventDefault()
                var errorFound = false
                var stopIds = document.getElementById('stopIdsInput').value.trim()
                if (stopIds === "") {
                    document.getElementById("stopIdsErrorMessage").innerText = "Stop ID(s) is required."
                    errorFound = true
                } else {
                    document.getElementById("stopIdsErrorMessage").innerText = ""
                }
                var trimmedStopIds = []
                var splitStopIds = stopIds.split(",")
                for (var i = 0; i < splitStopIds.length; i++) {
                    trimmedStopIds.push(splitStopIds[i].trim())
                }
                var url = "https://jo-room.github.io/mbta/?stops=" + trimmedStopIds.join(",")

                var config = document.getElementById('configInput').value
                if (config) {
                    try {
                        JSON.parse(config);
                    } catch (e) {
                        document.getElementById("configInputErrorMessage").innerText = "Invalid JSON." + e.toString()
                        return
                    }
                    document.getElementById("configInputErrorMessage").innerText = ""
                    var minified = JSON.stringify(JSON.parse(config));
                    url += "&config=" + encodeURI(minified)
                }
                if (errorFound) return
                document.getElementById("urlOutput").innerHTML = '<a href="' + url + '">' + url + '</a>'
            }

            function configureStops(){
                stopNums = stopsQueryParam.split(",");

                if (getQueryVariable("config")) {
                    stopConfigs = JSON.parse(decodeURI(getQueryVariable("config")))
                    if (stopConfigs["title"]) {
                        document.getElementById("title").innerText = stopConfigs["title"]
                        document.title = stopConfigs["title"] + " " + document.title
                    }
                }

                getAndSetStops()
            }

            function getAndSetStops(){
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function(event) {
                    if (xhttp.readyState == XMLHttpRequest.DONE) {
                        var stopsData = JSON.parse(xhttp.response).data
                        for (var i = 0; i < stopNums.length; i++) {
                            var stopData;
                            for (var j = 0; j < stopsData.length; j++) {
                                if (stopNums[i] == stopsData[j].id) {
                                    stopData = stopsData[j]
                                }
                            }

                            var el = document.createElement('div');
                            el.setAttribute('id', "stop-"+ stopNums[i])
                            var title;
                            if (stopConfigs[stopNums[i]] && stopConfigs[stopNums[i]]["name"]) {
                                title = stopConfigs[stopNums[i]]["name"]
                            }
                            else if (stopData.attributes.description){
                                title = stopData.attributes.description
                            } else {
                               title = stopData.attributes.name
                            }

                            if (stopConfigs[stopNums[i]] && stopConfigs[stopNums[i]]["message"]) {
                                title += " (" + stopConfigs[stopNums[i]]["message"] + ")"
                            }

                            el.innerHTML = '<h2 id="stop-title-' + stopNums[i] + '">' + title + '</h2><div id="stop-body-' + stopNums[i] +'"></div>';
                            document.getElementById("content").appendChild(el)
                       }
                       callAPIs()
                    }
                };
                pollIntervalID = setInterval(callAPIs, pollingInterval);
                xhttp.open("GET", "https://api-v3.mbta.com/stops" + "?filter[id]=" + stopNums.join(",") + "&fields[stop]=name,description", true);
                if (apiKey) {
                    xhttp.setRequestHeader('x-api-key', apiKey)
                }
                xhttp.send();
            }


            function callAPIs() {
                console.log('polling', pollNum)
                getPredictions()
            }

            function getPredictions(){
                var xhttp = new XMLHttpRequest();
                pollNum++;
                var currentPollNum = pollNum

                var now = new Date()
                var hours = now.getHours();
                var minutes = now.getMinutes();
                if (minutes < 10) {
                    minutes = "0" + minutes
                }
                var timeMessage;
                if (hours < 12){
                    timeMessage = hours + ":" + minutes + "am"
                } else if (hours == 12) {
                    timeMessage = hours + ":" + minutes + "pm"
                } else {
                    timeMessage = hours - 12 + ":" + minutes + "pm"
                }
                document.getElementById("clock").innerText = timeMessage
            
                xhttp.onerror = function(event) {
                    document.getElementById("message").innerText = "API call error: " + JSON.stringify(event)
                }
                xhttp.onreadystatechange = function(event) {
                    // only update if it's the most recent request to have come back
                    if (xhttp.readyState == XMLHttpRequest.DONE && latestReturnedPollNum < currentPollNum) {
                        latestReturnedPollNum = currentPollNum;
                        predictionData = JSON.parse(xhttp.response).data
                        document.getElementById("message").innerText = ""
                        updateUI()
                    }
                };
                xhttp.open("GET", "https://api-v3.mbta.com/predictions/?filter[stop]=" + stopNums.join(",") + "&sort=arrival_time", true);
                if (apiKey) {
                    xhttp.setRequestHeader('x-api-key', apiKey)
                }
                xhttp.send();
            }


            function updateUI(){
                if (predictionData) {
                    updatePredictions()
                }
            }

            function updatePredictions(){
                var predictions = {}
                for (var i = 0; i < stopNums.length; i++) {
                    predictions[stopNums[i]] = []
                }

                for (var i = 0; i < predictionData.length; i++) {
                    var prediction = predictionData[i]
                    var stopNum = prediction.relationships.stop.data.id

                    if (stopConfigs[stopNum] && stopConfigs[stopNum]["maxNumPredictions"] && predictions[stopNum].length >= stopConfigs[stopNum]["maxNumPredictions"]) {
                        continue;
                    }

                    var vehicleId;
                    if (prediction.relationships.vehicle.data) {
                        vehicleId = prediction.relationships.vehicle.data.id
                    }

                    var route = prediction.relationships.route.data.id
                    var shouldInclude = !(
                        (stopConfigs[stopNum] && stopConfigs[stopNum]["filterRoutes"] && (stopConfigs[stopNum]["filterRoutes"].indexOf(route) === -1))
                         || prediction.attributes.schedule_relationship === "CANCELLED")
                    if (shouldInclude) {
                        predictions[stopNum].push({
                            'id': prediction.id,
                            'route': route,
                            'status': prediction.attributes.status,
                            'arrivalTime': prediction.attributes.arrival_time,
                            'departureTime': prediction.attributes.departure_time,
                            'arrivalUncertainty': prediction.attributes.arrival_uncertainty,
                            'vehicleId': vehicleId,
                        })
                    }
                }

                var now = Date.now()
                for (var i = 0; i < stopNums.length; i++) {
                    var newStopEl = document.createElement('div');
                    newStopEl.setAttribute('id', "stop-body-"+ stopNums[i])

                    // sort by arrival/departure time
                    predictions[stopNums[i]].sort(function(a, b) {
                        var aSortTime = a.arrivalTime
                        if (!aSortTime) {
                            aSortTime = a.departureTime
                        }
                        var bSortTime = b.arrivalTime
                        if (!bSortTime) {
                            bSortTime = b.departureTime
                        }
                        return aSortTime.localeCompare(bSortTime);
                    });

                    for (var j = 0; j < predictions[stopNums[i]].length; j++) {
                        prediction = predictions[stopNums[i]][j]
                        var showNegative = false;
                        if (stopConfigs[stopNums[i]] && stopConfigs[stopNums[i]]["showNegative"]) {
                            showNegative = true;
                        }

                        var routeName;
                        if (stopConfigs[stopNums[i]] && stopConfigs[stopNums[i]]["routeName"]) {
                            routeName = stopConfigs[stopNums[i]]["routeName"]
                        } else {
                            routeName = prediction.route
                        }

                        var showVehicleId = false;
                        if (stopConfigs[stopNums[i]] && stopConfigs[stopNums[i]]["showVehicleId"]) {
                            showVehicleId = true;
                        }

                        var predictionMessage = formatPredictionMessage(now, prediction, showNegative, routeName, showVehicleId)

                        if (predictionMessage) {
                            var predictionEl = document.createElement('div');
                            predictionEl.innerText = predictionMessage
                            newStopEl.appendChild(predictionEl)
                        }
                    }
                    document.getElementById("stop-body-"+stopNums[i]).innerHTML = newStopEl.innerHTML
                }
            }

            function formatPredictionMessage(now, prediction, showNegative, routeName, showVehicleId){
                var predictedTime
                if (!prediction.arrivalTime){
                    predictedTime = new Date(prediction.departureTime)
                } else {
                    predictedTime = new Date(prediction.arrivalTime)       
                }
                var minLeft = Math.round((predictedTime - now) / msPerMin)
                
                var timeMessage = "";
                
                if (minLeft < 0 && !showNegative) {
                    return null
                } else if (minLeft < 60) {
                    timeMessage = minLeft + " min"
                } else {
                    var hours = predictedTime.getHours();
                    var minutes = predictedTime.getMinutes();
                    if (minutes < 10) {
                        minutes = "0" + minutes
                    }
                    if (hours < 12){
                        timeMessage = hours + "." + minutes + " am"
                    } else if (hours == 12) {
                        timeMessage = hours + "." + minutes + " pm"
                    } else {
                        timeMessage = hours - 12 + "." + minutes + " pm"
                    }
                }

                var predictionMessage = routeName + ": " + timeMessage

                if (prediction.status){
                    predictionMessage += " - " + prediction.status
                }

                // https://github.com/mbta/gtfs-documentation/blob/master/reference/gtfs-realtime.md#uncertainty-values
                // Mushing together both bus and rail codes
                if (prediction.arrivalUncertainty){
                    switch (true) {
                        case prediction.arrivalUncertainty == 60:
                            // Train: trip has started
                            break;
                        case prediction.arrivalUncertainty == 120:
                            // Train: A terminal/reverse trip departure for a trip that has NOT started and a train is awaiting departure at the origin
                            predictionMessage += " ~ waiting at origin"
                            break;
                        case prediction.arrivalUncertainty == 360:
                            // Train: A terminal/reverse trip for a trip that has NOT started and a train is completing a previous trip
                            predictionMessage += " ~ completing prev trip"
                            break;
                            // return null; // THIS IS A RETURN
                        case prediction.arrivalUncertainty < 300:
                            // Bus: Valid real-time prediction
                            break;
                        case prediction.arrivalUncertainty == 300:
                            // Bus: Real-time prediction not available. This code is primarily used when a vehicle has not yet been assigned to the trip, (i.e. because the block has not started yet). It is a schedule-based prediction, but we adjust the schedule-based prediction time using observed historical travel times to make predictions more accurate than the schedule.
                            predictionMessage += " ~ adjusted schedule"
                            break;
                        case prediction.arrivalUncertainty == 301:
                            // Bus: Valid real-time prediction, though the bus appears to be stalled or significantly delayed and predictions are not as accurate
                            predictionMessage += " ~ stalled/delayed"
                            break;
                        case prediction.arrivalUncertainty > 301:
                            // Bus: Likely invalid prediction, recommend not showing anything (and not showing scheduled time), very rare situation.
                            return null; // THIS IS A RETURN
                        default:
                            predictionMessage += " ~ unexpected code spot"
                    }
                }

                if (showVehicleId) {
                    predictionMessage += " - " + prediction.vehicleId
                }
                
                return predictionMessage
            }

            function getQueryVariable(variable) {
               var query = window.location.search.substring(1);
               var vars = query.split("&");
               for (var i=0;i<vars.length;i++) {
                   var pair = vars[i].split("=");
                   if(pair[0] == variable){return pair[1];}
               }
               return(false);
           }
        </script>
    </body>
</html>
